From 532f067cca2113ea289282ea57e594efab5ba2a0 Mon Sep 17 00:00:00 2001
From: John Stebbins <jstebbins.hb@gmail.com>
Date: Thu, 6 Jul 2017 09:15:21 -0700
Subject: [PATCH] fix use of deprecated libav defines

Fixes https://github.com/HandBrake/HandBrake/issues/815
---
 libhb/decavcodec.c      |  2 +-
 libhb/encavcodec.c      | 10 +++++-----
 libhb/encavcodecaudio.c |  4 ++--
 libhb/hb.c              |  2 +-
 libhb/muxavformat.c     | 28 ++++++++++++++--------------
 5 files changed, 23 insertions(+), 23 deletions(-)

diff --git a/libhb/decavcodec.c b/libhb/decavcodec.c
index a6f120800..74d07d21b 100644
--- a/libhb/decavcodec.c
+++ b/libhb/decavcodec.c
@@ -1584,7 +1584,7 @@ static int setup_extradata( hb_work_object_t *w, hb_buffer_t *in )
             {
                 pv->context->extradata_size = size;
                 pv->context->extradata =
-                                av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);
+                                av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (pv->context->extradata == NULL)
                     return 1;
                 memcpy(pv->context->extradata, in->data, size);
diff --git a/libhb/encavcodec.c b/libhb/encavcodec.c
index 76fe3e7c7..59d491148 100644
--- a/libhb/encavcodec.c
+++ b/libhb/encavcodec.c
@@ -235,7 +235,7 @@ int encavcodecInit( hb_work_object_t * w, hb_job_t * job )
         /* Constant quantizer */
         // These settings produce better image quality than
         // what was previously used
-        context->flags |= CODEC_FLAG_QSCALE;
+        context->flags |= AV_CODEC_FLAG_QSCALE;
         context->global_quality = FF_QP2LAMBDA * job->vquality + 0.5;
         //Set constant quality for libvpx
         if ( w->codec_param == AV_CODEC_ID_VP8 ||
@@ -278,11 +278,11 @@ int encavcodecInit( hb_work_object_t * w, hb_job_t * job )
 
     if( job->mux & HB_MUX_MASK_MP4 )
     {
-        context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+        context->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
     }
     if( job->grayscale )
     {
-        context->flags |= CODEC_FLAG_GRAY;
+        context->flags |= AV_CODEC_FLAG_GRAY;
     }
 
     if( job->pass_id == HB_PASS_ENCODE_1ST ||
@@ -302,7 +302,7 @@ int encavcodecInit( hb_work_object_t * w, hb_job_t * job )
                 ret = 1;
                 goto done;
             }
-            context->flags |= CODEC_FLAG_PASS1;
+            context->flags |= AV_CODEC_FLAG_PASS1;
         }
         else
         {
@@ -341,7 +341,7 @@ int encavcodecInit( hb_work_object_t * w, hb_job_t * job )
             fclose( pv->file );
             pv->file = NULL;
 
-            context->flags    |= CODEC_FLAG_PASS2;
+            context->flags    |= AV_CODEC_FLAG_PASS2;
             context->stats_in  = log;
         }
     }
diff --git a/libhb/encavcodecaudio.c b/libhb/encavcodecaudio.c
index 5f95c7383..ad3f7e3f7 100644
--- a/libhb/encavcodecaudio.c
+++ b/libhb/encavcodecaudio.c
@@ -178,7 +178,7 @@ static int encavcodecaInit(hb_work_object_t *w, hb_job_t *job)
     else if (audio->config.out.quality >= 0)
     {
         context->global_quality = audio->config.out.quality * FF_QP2LAMBDA;
-        context->flags |= CODEC_FLAG_QSCALE;
+        context->flags |= AV_CODEC_FLAG_QSCALE;
         if (audio->config.out.codec == HB_ACODEC_FDK_AAC ||
             audio->config.out.codec == HB_ACODEC_FDK_HAAC)
         {
@@ -197,7 +197,7 @@ static int encavcodecaInit(hb_work_object_t *w, hb_job_t *job)
     // so that it fills extradata with global header information.
     // If this flag is not set, it inserts the data into each
     // packet instead.
-    context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+    context->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
     if (hb_avcodec_open(context, codec, &av_opts, 0))
     {
diff --git a/libhb/hb.c b/libhb/hb.c
index 3df3ec3ac..77cf6b2bf 100644
--- a/libhb/hb.c
+++ b/libhb/hb.c
@@ -130,7 +130,7 @@ int hb_avcodec_open(AVCodecContext *avctx, AVCodec *codec,
         avctx->thread_count = 1;
     }
 
-    if (codec->capabilities & CODEC_CAP_EXPERIMENTAL)
+    if (codec->capabilities & AV_CODEC_CAP_EXPERIMENTAL)
     {
         // "experimental" encoders will not open without this
         avctx->strict_std_compliance = FF_COMPLIANCE_EXPERIMENTAL;
diff --git a/libhb/muxavformat.c b/libhb/muxavformat.c
index f628b9628..cad3c09de 100644
--- a/libhb/muxavformat.c
+++ b/libhb/muxavformat.c
@@ -219,7 +219,7 @@ static int avformatInit( hb_mux_object_t * m )
             /* Taken from x264 muxers.c */
             priv_size = 5 + 1 + 2 + job->config.h264.sps_length + 1 + 2 +
                         job->config.h264.pps_length;
-            priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (priv_data == NULL)
             {
                 hb_error("H.264 extradata: malloc failure");
@@ -255,7 +255,7 @@ static int avformatInit( hb_mux_object_t * m )
             if (job->config.mpeg4.length != 0)
             {
                 priv_size = job->config.mpeg4.length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("MPEG4 extradata: malloc failure");
@@ -271,7 +271,7 @@ static int avformatInit( hb_mux_object_t * m )
             if (job->config.mpeg4.length != 0)
             {
                 priv_size = job->config.mpeg4.length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("MPEG2 extradata: malloc failure");
@@ -307,7 +307,7 @@ static int avformatInit( hb_mux_object_t * m )
             }
 
             priv_size = size;
-            priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (priv_data == NULL)
             {
                 hb_error("Theora extradata: malloc failure");
@@ -337,7 +337,7 @@ static int avformatInit( hb_mux_object_t * m )
             if (job->config.h265.headers_length > 0)
             {
                 priv_size = job->config.h265.headers_length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("H.265 extradata: malloc failure");
@@ -450,7 +450,7 @@ static int avformatInit( hb_mux_object_t * m )
                 }
 
                 priv_size = size;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("Vorbis extradata: malloc failure");
@@ -473,7 +473,7 @@ static int avformatInit( hb_mux_object_t * m )
                 if (audio->priv.config.extradata.length)
                 {
                     priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                     if (priv_data == NULL)
                     {
                         hb_error("OPUS extradata: malloc failure");
@@ -491,7 +491,7 @@ static int avformatInit( hb_mux_object_t * m )
                 if (audio->priv.config.extradata.length)
                 {
                     priv_size = audio->priv.config.extradata.length;
-                    priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                    priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                     if (priv_data == NULL)
                     {
                         hb_error("FLAC extradata: malloc failure");
@@ -517,7 +517,7 @@ static int avformatInit( hb_mux_object_t * m )
                 //
                 // So allocate extra bytes
                 priv_size = audio->priv.config.extradata.length;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("AAC extradata: malloc failure");
@@ -758,7 +758,7 @@ static int avformatInit( hb_mux_object_t * m )
                         rgb[12], rgb[13], rgb[14], rgb[15]);
 
                 priv_size = len + 1;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("VOBSUB extradata: malloc failure");
@@ -791,7 +791,7 @@ static int avformatInit( hb_mux_object_t * m )
                     if (subtitle->extradata_size)
                     {
                         priv_size = subtitle->extradata_size;
-                        priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                        priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                         if (priv_data == NULL)
                         {
                             hb_error("SSA extradata: malloc failure");
@@ -841,7 +841,7 @@ static int avformatInit( hb_mux_object_t * m )
             properties[17] = width & 0xff;
 
             priv_size = sizeof(properties);
-            priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+            priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
             if (priv_data == NULL)
             {
                 hb_error("TX3G extradata: malloc failure");
@@ -898,7 +898,7 @@ static int avformatInit( hb_mux_object_t * m )
                 }
 
                 priv_size = attachment->size;
-                priv_data = av_malloc(priv_size + FF_INPUT_BUFFER_PADDING_SIZE);
+                priv_data = av_malloc(priv_size + AV_INPUT_BUFFER_PADDING_SIZE);
                 if (priv_data == NULL)
                 {
                     hb_error("Font extradata: malloc failure");
@@ -1448,7 +1448,7 @@ static int avformatEnd(hb_mux_object_t *m)
 
                     priv_size = audio->priv.config.extradata.length;
                     priv_data = av_realloc(st->codecpar->extradata, priv_size +
-                                           FF_INPUT_BUFFER_PADDING_SIZE);
+                                           AV_INPUT_BUFFER_PADDING_SIZE);
                     if (priv_data == NULL)
                     {
                         break;
From f002cf7ad405b93c5bc52e3f12c960c4514b7957 Mon Sep 17 00:00:00 2001
From: John Stebbins <jstebbins.hb@gmail.com>
Date: Thu, 6 Jul 2017 11:42:25 -0700
Subject: [PATCH] fix another use of deprecated libav define

---
 libhb/encavcodecaudio.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libhb/encavcodecaudio.c b/libhb/encavcodecaudio.c
index ad3f7e3f7..e13963292 100644
--- a/libhb/encavcodecaudio.c
+++ b/libhb/encavcodecaudio.c
@@ -223,7 +223,7 @@ static int encavcodecaInit(hb_work_object_t *w, hb_job_t *job)
     pv->input_buf         = malloc(pv->input_samples * sizeof(float));
     // Some encoders in libav (e.g. fdk-aac) fail if the output buffer
     // size is not some minumum value.  8K seems to be enough :(
-    pv->max_output_bytes  = MAX(FF_MIN_BUFFER_SIZE,
+    pv->max_output_bytes  = MAX(AV_INPUT_BUFFER_MIN_SIZE,
                                 (pv->input_samples *
                                  av_get_bytes_per_sample(context->sample_fmt)));
 

